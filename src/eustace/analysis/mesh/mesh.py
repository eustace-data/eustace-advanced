"""Mesh."""

import numpy

class Mesh(object):
    """Generic base class for mesh."""

    def __init__(self, points, triangles, edges):
        """Construct from given data."""

        self.points = points
        self.triangles = triangles
        self.edges = edges

class MeshIcosahedron(Mesh):
    """Icosahedron mesh."""

    BASE_HASH_SHIFT = numpy.uint64(58)
    """Use this number to left-shift triangle indices to allow subdivision.

       5 bits to the left of this are required for representing the
       base triangle number in icosahedron, and so this is close to the
       largest value possible in 64-bit.
       Could use 59 but would overwrite sign bit, and would not benefit from 
       additional subdivisions as two bits required for each subdivision."""

    def __init__(self, points, triangles, edges, level):
        """Construct from given data."""
        
        # Build object using base class constructor
        super(MeshIcosahedron, self).__init__(points, triangles, edges)

        # Level allows subdivision
        self.level = level

    @staticmethod
    def golden_ratio_basis():
        """Build components of unit vector [ a, b, 0 ] proportional to [ r, 1, 0 ]
           where r is the golden ratio (1 + sqrt(5)) / 2 ."""

         # The golden ratio
        r = (1.0 + numpy.sqrt(5.0)) * 0.5

        # Normalising factor n = | [ r, 1, 0 ] |
        n = numpy.sqrt(1.0 + r*r)

        # Components such that:
        #  [ a, b, 0 ] = [ r, 1, 0 ] / n
        a = r / n
        b = 1.0 / n

        return a, b

    @staticmethod
    def inter_vertex_angle():
        """Compute angle between two vertices in radians - useful for rotating so that there are faces at the z-axis poles."""

        # The golden ratio computation used to generate points
        a, b = MeshIcosahedron.golden_ratio_basis()

        # One minus the inverse ratio
        one_minus_inverse_ratio = 1.0 - (b / a)

        # Sine of angle
        sin_theta = 1.0 / numpy.sqrt(1.0 + one_minus_inverse_ratio*one_minus_inverse_ratio)

        # Result
        return numpy.arcsin(sin_theta)
    
    @staticmethod
    def build():
        """Factory method to build it from first principles."""

        # The twelve vertices of a regular icosahedron
        # are generated by all cyclic
        # permutations and sign-flips of [ r, 1, 0 ]
        # where r is the golden ratio (1 + sqrt(5)) / 2.
        #
        # To generate a unit icosahedron, also
        # normalise these by dividing by length
        # - the golden_ratio_basis method does this for us.
        #
        a, b = MeshIcosahedron.golden_ratio_basis()

        # Build points
        points = numpy.array([
            [ +a, +b,  0 ],   #% ZA
            [ -a, +b,  0 ],   #% ZB
            [ -a, -b,  0 ],   #% ZC
            [ +a, -b,  0 ],   #% ZD
            [ +b,  0, +a ],   #% YA
            [ +b,  0, -a ],   #% YB
            [ -b,  0, -a ],   #% YC
            [ -b,  0, +a ],   #% YD
            [  0, +a, +b ],   #% XA
            [  0, -a, +b ],   #% XB
            [  0, -a, -b ],   #% XC
            [  0, +a, -b ] ]) #% XD

        # Triangle and point indices (zero-based)
        # These should all be clockwise
        triangles = numpy.array(
            [[ 0,  4,  7,  8],
             [ 1,  4,  9,  7],
             [ 2,  5, 11,  6],
             [ 3,  5,  6, 10],
             [ 4,  0,  3,  4],
             [ 5,  0,  5,  3],
             [ 6,  2,  1,  7],
             [ 7,  2,  6,  1],
             [ 8,  8, 11,  0],
             [ 9,  8,  1, 11],
             [10,  9,  3, 10],
             [11,  9, 10,  2],
             [12,  8,  0,  4],
             [13, 11,  5,  0],
             [14,  4,  3,  9],
             [15,  5, 10,  3],
             [16,  7,  1,  8],
             [17,  6, 11,  1],
             [18,  7,  9,  2],
             [19,  6,  2, 10]], numpy.uint64)

        # Also left-shift the indices
        triangles[:,0] = triangles[:,0] << MeshIcosahedron.BASE_HASH_SHIFT

        # Each edge has two triangles and two points
        # Make array with rows like:
        # [ pointA, pointB, triangle number, clockwise edge number ]
        point_pairs = numpy.empty((3*triangles.shape[0],4), numpy.uint64)

        # Build edges per triangle
        # Last two columns indicate [index of point, index of connecting point,...]
        # And there are three such rows per triangle
        point_pairs[0::3,0] = triangles[:,1]
        point_pairs[0::3,1] = triangles[:,2]
        point_pairs[1::3,0] = triangles[:,2]
        point_pairs[1::3,1] = triangles[:,3]
        point_pairs[2::3,0] = triangles[:,3]
        point_pairs[2::3,1] = triangles[:,1]
        
        # Put triangle number in third column
        point_pairs[0::3,2] = triangles[:,0]
        point_pairs[1::3,2] = triangles[:,0]
        point_pairs[2::3,2] = triangles[:,0]

        # The points are ordered so that they are clockwise
        # Put a counter in 4th column so we can know what this
        # ordering was even if list is rearranged
        point_pairs[0::3,3] = 0
        point_pairs[1::3,3] = 1
        point_pairs[2::3,3] = 2

        # Make an identifier for each row which uniquely identifies each edge
        # (independent of point ordering)
        mask_order_A = (point_pairs[:,0] < point_pairs[:,1])
        mask_order_B = (point_pairs[:,1] < point_pairs[:,0])
        edgeids = mask_order_A*(point_pairs[:,0]*points.shape[0] + point_pairs[:,1]) + \
                  mask_order_B*(point_pairs[:,1]*points.shape[0] + point_pairs[:,0])

        # Sort all edges using edge id to put corresponding edges next to each other
        indices = numpy.argsort(edgeids)

        # Combine into single array with one row per edge, with 6 columns of details:
        #
        # [ point id 0, point id 1, triangle 0 id, triangle 0 edge number, triangle 1 id, triangle 1 edge number ]
        #
        # Triangle 0 clockwise traversal is always forward direction (point 0 --> point 1)
        # Triangle 1 clockwise traversal is always reverse direction (point 1 --> point 0)
        #
        edges = numpy.empty((indices.shape[0]/2, 6), numpy.uint64)
        edges[:,0:4] = point_pairs[indices[0::2],:]
        edges[:,4:6] = point_pairs[indices[1::2],2:4]

        # Return result
        return MeshIcosahedron(points, triangles, edges, level=numpy.uint64(0))

    def rotate_y(self, theta):
        """Rotate all points anti-clockwise about y-axis by angle theta (radians)."""

        # Make rotation  matrix about y-axis
        c = numpy.cos(theta)
        s = numpy.sin(theta)
        R = numpy.array( [ [ c, 0,-s ], 
                           [ 0, 1, 0 ],
                           [ s, 0, c ] ] )

        # Modify points
        self.points = numpy.matmul(self.points, R.T)


class MeshIcosahedronSubdivision(MeshIcosahedron):
    """Subdivided icosahedron."""

    def __init__(self, points, triangles, edges, level):
        """Construct from given data."""
        
        # Build object using parent class constructor
        super(MeshIcosahedronSubdivision, self).__init__(points, triangles, edges, level)
        
    @staticmethod
    def build(number_of_subdivisions, project_onto_sphere=True, face_centre_at_poles=False):
        """Factory method to build new mesh by subdividing icosahedron a number of times."""

        # Make it
        mesh = MeshIcosahedron.build()

        # Optionally rotate to put z-axis poles at face centres
        if face_centre_at_poles:
            mesh.rotate_y(MeshIcosahedron.inter_vertex_angle())

        # Subdivide
        for level in range(number_of_subdivisions):
            mesh = MeshIcosahedronSubdivision.subdivide(mesh, project_onto_sphere)

        return mesh

    @staticmethod
    def subdivide(parent, project_onto_sphere=True):
        """Factory to build from a parent (possibly subdivided) icosahedron."""

        # Get the critical numbers for parent
        parent_num_points = parent.points.shape[0]
        parent_num_triangles = parent.triangles.shape[0]
        parent_num_edges = parent.edges.shape[0]

        # Increment subdivision level
        level = parent.level + numpy.uint64(1)

        # All the original points plus an extra point for every edge
        child_num_points = parent_num_points + parent_num_edges
        points = numpy.empty((child_num_points, 3), numpy.float64)
        
        # Every triangle is replaced by 4 new ones
        child_num_triangles = 4*parent_num_triangles
        triangles = numpy.empty((child_num_triangles, 4), numpy.uint64)

        # Each existing edge splits in two and there are three new edges per parent triangle
        child_num_edges = 2*parent_num_edges + 3*parent_num_triangles
        edges = numpy.empty((child_num_edges, 6), numpy.uint64)

        # Generate the new mid-points and normalise (project outwards onto sphere) if requested
        newmidpoints = (parent.points[parent.edges[:,0],:] + parent.points[parent.edges[:,1],:]) * 0.5
        if project_onto_sphere:
            normalisation_factor = numpy.transpose(numpy.tile(numpy.linalg.norm(newmidpoints, axis=1), (3,1)))
            newmidpoints /= normalisation_factor

        # Copy old points
        points[0:parent_num_points,:] = parent.points

        # Store new midpoints
        points[parent_num_points:child_num_points,:] = newmidpoints

        
        # Record the 'split-in-two' edges
        # 

        # This is used to move local triangle number bits
        # to where they need to be to make global triangle id
        hash_shift = numpy.uint64(MeshIcosahedron.BASE_HASH_SHIFT - numpy.uint64(2)*level)

        # First half of each existing edge in even-numbered rows

        # --existing point from parent as start
        edges[0:(2*parent_num_edges):2,0] = parent.edges[:,0]

        # --new indices into mid-points
        edges[0:(2*parent_num_edges):2,1] = range(parent_num_points, child_num_points, 1)

        # --will belong to a triangle with parent in most signficiant bits and first edge number in next ones
        edges[0:(2*parent_num_edges):2,2] = parent.edges[:,2] | (parent.edges[:,3] << hash_shift)

        # --edge number stays the same
        edges[0:(2*parent_num_edges):2,3] = parent.edges[:,3]

        # --will belong to a triangle with parent in most signficiant bits and second edge number + 1 in next ones
        edges[0:(2*parent_num_edges):2,4] = parent.edges[:,4] | (((parent.edges[:,5] + 1) % 3) << hash_shift)

        # --edge number stays the same
        edges[0:(2*parent_num_edges):2,5] = parent.edges[:,5]


        # Second half of each existing edge: initially put parent triangle numbers in

        # --new indices into mid-points
        edges[1:(2*parent_num_edges):2,0] = range(parent_num_points, child_num_points, 1)

        # --existing point from parent as end
        edges[1:(2*parent_num_edges):2,1] = parent.edges[:,1]

        # --will belong to a triangle with parent in most signficiant bits and first edge number + 1 in next ones
        edges[1:(2*parent_num_edges):2,2] = parent.edges[:,2] | (((parent.edges[:,3] + 1) % 3) << hash_shift)

        # --edge number stays the same
        edges[1:(2*parent_num_edges):2,3] = parent.edges[:,3]

        # --will belong to a triangle with parent in most signficiant bits and second edge number in next ones
        edges[1:(2*parent_num_edges):2,4] = parent.edges[:,4] | (parent.edges[:,5] << hash_shift)

        # --edge number stays the same
        edges[1:(2*parent_num_edges):2,5] = parent.edges[:,5]
        
        # Matrix in which rows are [ index of midpoint | parent triangle | clockwise index in parent ]
        # And there are two rows for each midpoint (one for each parent triangle associated with it)
        midpoints = numpy.empty((2*parent_num_edges, 3), numpy.uint64)
        midpoints[0:parent_num_edges,0] = range(parent_num_points, child_num_points, 1)
        midpoints[0:parent_num_edges,1] = parent.edges[:,2]
        midpoints[0:parent_num_edges,2] = parent.edges[:,3]
        midpoints[parent_num_edges: ,0] = range(parent_num_points, child_num_points, 1)
        midpoints[parent_num_edges: ,1] = parent.edges[:,4]
        midpoints[parent_num_edges: ,2] = parent.edges[:,5]

        # Sort by parent triangle as primary key and clockwise index as secondary
        # so that rows in same triangle are next to one another
        # NOTE: this limits useable bits
        sort_criteria = midpoints[:,1]  | midpoints[:,2]
        indices = numpy.argsort(sort_criteria)
        midpoints = midpoints[indices,:]

        # Record the edges and triangles formed by connecting up mid-points
        # m0---m1, m1---m2, m2---m0 as follows:
        #        
        #                  /\
        #                 /  \
        #               e0    e1
        #               /  t1  \
        #              /        \
        #             m0---e2---m1
        #             /\         /\
        #            /  \  t3   /  \
        #          e0    e1   e0    e1
        #          /  t0  \   /  t2  \
        #         /        \ /        \
        #        /----------m2---------\

        # First edge: mid point 0 --> mid point 2 forms edge 1 in sub-triangle 0
        edges[(2*parent_num_edges)::3,0] = midpoints[0::3, 0] # index to point 0
        edges[(2*parent_num_edges)::3,1] = midpoints[2::3, 0] # index to point 2
        edges[(2*parent_num_edges)::3,2] = midpoints[0::3, 1] | (numpy.uint64(0) << hash_shift)
        edges[(2*parent_num_edges)::3,3] = 1 # clockwise edge number within triangle 0

        # First edge: mid point 2 --> mid point 0 forms edge 1 in sub-triangle 3
        edges[(2*parent_num_edges)::3,4] = midpoints[2::3, 1] | (numpy.uint64(3) << hash_shift)
        edges[(2*parent_num_edges)::3,5] = 1 # clockwise edge number within triangle 3

        # Second edge: mid point 1 --> mid point 0 forms edge 2 in sub-triangle 1
        edges[(1+2*parent_num_edges)::3,0] = midpoints[1::3, 0] # index to point 1
        edges[(1+2*parent_num_edges)::3,1] = midpoints[0::3, 0] # index to point 0
        edges[(1+2*parent_num_edges)::3,2] = midpoints[1::3, 1] | (numpy.uint64(1) << hash_shift)
        edges[(1+2*parent_num_edges)::3,3] = 2 # clockwise edge number within triangle 1

        # Second edge: mid point 0 --> mid point 1 forms edge 2 in sub-triangle 3
        edges[(1+2*parent_num_edges)::3,4] = midpoints[0::3, 1] | (numpy.uint64(3) << hash_shift)
        edges[(1+2*parent_num_edges)::3,5] = 2 # clockwise edge number within triangle 3

        # Third edge: mid point 2 --> mid point 1 forms edge 0 in sub-triangle 2
        edges[(2+2*parent_num_edges)::3,0] = midpoints[2::3, 0] # index to point 1
        edges[(2+2*parent_num_edges)::3,1] = midpoints[1::3, 0] # index to point 0
        edges[(2+2*parent_num_edges)::3,2] = midpoints[2::3, 1] | (numpy.uint64(2) << hash_shift)
        edges[(2+2*parent_num_edges)::3,3] = 0 # clockwise edge number within triangle 2

        # Third edge: mid point 1 --> mid point 2 forms edge 0 in sub-triangle 3
        edges[(2+2*parent_num_edges)::3,4] = midpoints[1::3, 1] | (numpy.uint64(3) << hash_shift)
        edges[(2+2*parent_num_edges)::3,5] = 0 # clockwise edge number within triangle 3

        # get the three edges for every triangle (will have duplicates because triangles share common edges)
        edges_with_duplicates = numpy.vstack((edges[:,0:4], numpy.hstack((edges[:,1::-1], edges[:,4:6]))))

        # sort according to triangle number
        sort_by_triangle = numpy.argsort(edges_with_duplicates[:,2] | edges_with_duplicates[:,3])
        sorted_edges_with_duplicates = edges_with_duplicates[sort_by_triangle,:]

        # list triangles
        triangles[:,0] = sorted_edges_with_duplicates[0::3,2]
        triangles[:,1] = sorted_edges_with_duplicates[0::3,0]
        triangles[:,2] = sorted_edges_with_duplicates[1::3,0]
        triangles[:,3] = sorted_edges_with_duplicates[2::3,0]

        # Return object
        return MeshIcosahedronSubdivision(points, triangles, edges, level)

